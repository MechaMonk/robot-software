{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Robot software stack Content This repo contains all the software used on our robots: can-io-firmware contains the firmware that runs on the IO board motor-control-firmware contains the firmware that runs on the motor board proximity-beacon-firmware contains the firmware that runs on the proximity beacon, it's the same code as the motor board but with a different application that is tailored to the needs of our proximity beacon module master-firmware contains the software that runs on the master board, it interfaces all the other boards over CAN and runs the robot's \"intelligence\". eurobot contains documentation and cofiguration files specific to the Eurobot competition sensor-firmware contains code running on the sensor board uwb-beacon-firmware contains code and documentation that runs on the UWB beacon board Other important software components can be found in this repo: lib contains all the libraries and building blocks we use on multiple boards, which includes: lib/can-bootloader the bootloader that allows us to update our boards (IO and motor) over CAN lib/ChibiOS the RTOS/HAL we use on all our boards lib/uavcan the CAN communication library we use on all our boards lib/error a logging library lib/parameter a library to create and manage configurations of boards lib/msgbus a publish/subscribe library for inter thread communication and more. tools groups all tools we use to develop on the robot including: tools/pid-tuner a GUI to tune PID gains of motor boards over CAN, written using Python and Qt tools/studio a set of introspection tools written in Python and Qt to debug our robots uavcan_data_types contains the custom message definitions (DSDL) for the UAVCAN communication protocol ci groups scripts and Docker files for our continuous integration server user-guide contains high-level documentation about software and electronics components used on our robots Coding style We use clang-format (tested with version 7 or greater) to enforce proper source code formatting. You can use the format-all.sh script in the root directory to format the whole source tree. You can also use clang-format -i --style=file src/foo.c to format a particular file. Finally, some editors include support for clang-format through plugin, check for yourself.","title":"Home"},{"location":"#robot-software-stack","text":"","title":"Robot software stack"},{"location":"#content","text":"This repo contains all the software used on our robots: can-io-firmware contains the firmware that runs on the IO board motor-control-firmware contains the firmware that runs on the motor board proximity-beacon-firmware contains the firmware that runs on the proximity beacon, it's the same code as the motor board but with a different application that is tailored to the needs of our proximity beacon module master-firmware contains the software that runs on the master board, it interfaces all the other boards over CAN and runs the robot's \"intelligence\". eurobot contains documentation and cofiguration files specific to the Eurobot competition sensor-firmware contains code running on the sensor board uwb-beacon-firmware contains code and documentation that runs on the UWB beacon board Other important software components can be found in this repo: lib contains all the libraries and building blocks we use on multiple boards, which includes: lib/can-bootloader the bootloader that allows us to update our boards (IO and motor) over CAN lib/ChibiOS the RTOS/HAL we use on all our boards lib/uavcan the CAN communication library we use on all our boards lib/error a logging library lib/parameter a library to create and manage configurations of boards lib/msgbus a publish/subscribe library for inter thread communication and more. tools groups all tools we use to develop on the robot including: tools/pid-tuner a GUI to tune PID gains of motor boards over CAN, written using Python and Qt tools/studio a set of introspection tools written in Python and Qt to debug our robots uavcan_data_types contains the custom message definitions (DSDL) for the UAVCAN communication protocol ci groups scripts and Docker files for our continuous integration server user-guide contains high-level documentation about software and electronics components used on our robots","title":"Content"},{"location":"#coding-style","text":"We use clang-format (tested with version 7 or greater) to enforce proper source code formatting. You can use the format-all.sh script in the root directory to format the whole source tree. You can also use clang-format -i --style=file src/foo.c to format a particular file. Finally, some editors include support for clang-format through plugin, check for yourself.","title":"Coding style"},{"location":"can/adapter/","text":"CAN USB adapter The CAN USB adapter allows us to inspect the CAN bus of our robots from our laptops, very convenient. It acts as a read / write translator over the CAN bus, relaying all the traffic over USB, through serial line CAN (SLCAN). UAVCAN supports SLCAN interfaces, and provides a Python library . This means we can easily interact with the boards on the bus through Python scripts. In fact, this is how we build most of our introspection tools. We also use this adapter to flash our boards over CAN using our bootloader . Summary of features: CAN interface with communication over UAVCAN. Molex Picoblade connectors for wiring CAN in daisy chain. Micro USB connector that exposes a serial interface and a CAN interface (over SLCAN). It can also be used for flashing the adapter using DFU. Costs < 20 USD in components. Links Hardware including KiCad files, the schematics in PDF, and gerber files. Software using ChibiOS RTOS/HAL, and UAVCAN for communication.","title":"CAN USB adapter"},{"location":"can/adapter/#can-usb-adapter","text":"The CAN USB adapter allows us to inspect the CAN bus of our robots from our laptops, very convenient. It acts as a read / write translator over the CAN bus, relaying all the traffic over USB, through serial line CAN (SLCAN). UAVCAN supports SLCAN interfaces, and provides a Python library . This means we can easily interact with the boards on the bus through Python scripts. In fact, this is how we build most of our introspection tools. We also use this adapter to flash our boards over CAN using our bootloader . Summary of features: CAN interface with communication over UAVCAN. Molex Picoblade connectors for wiring CAN in daisy chain. Micro USB connector that exposes a serial interface and a CAN interface (over SLCAN). It can also be used for flashing the adapter using DFU. Costs < 20 USD in components.","title":"CAN USB adapter"},{"location":"can/adapter/#links","text":"Hardware including KiCad files, the schematics in PDF, and gerber files. Software using ChibiOS RTOS/HAL, and UAVCAN for communication.","title":"Links"},{"location":"can/beacon/","text":"Beacon board The Beacon board is a 42x30mm with a dedicated STM32F4 microcontroller and the following features: CAN interface with communication over UAVCAN. CAN bootloader for easy firmware update over the bus. An Ultra-Wide Band (UWB) module from Decawave for communication and beacon to beacon distance measurement Molex Picoblade connection for wiring CAN in daisy chain. Micro USB connector for debugging and flashing via DFU. SWD connector for flashing and debugging, with UART exposed on the same connector. 4x M2 holes for mounting. Costs < 50 USD in components. Still a work in progress. Currently basic communication is implemented and distance measurement at low update rate. Links Hardware including KiCad files, the schematics in PDF, and gerber files. Software using ChibiOS RTOS/HAL, and UAVCAN for communication. Bootloader based on libOpenCM3 and a custom lightweight protocol.","title":"Beacon board"},{"location":"can/beacon/#beacon-board","text":"The Beacon board is a 42x30mm with a dedicated STM32F4 microcontroller and the following features: CAN interface with communication over UAVCAN. CAN bootloader for easy firmware update over the bus. An Ultra-Wide Band (UWB) module from Decawave for communication and beacon to beacon distance measurement Molex Picoblade connection for wiring CAN in daisy chain. Micro USB connector for debugging and flashing via DFU. SWD connector for flashing and debugging, with UART exposed on the same connector. 4x M2 holes for mounting. Costs < 50 USD in components. Still a work in progress. Currently basic communication is implemented and distance measurement at low update rate.","title":"Beacon board"},{"location":"can/beacon/#links","text":"Hardware including KiCad files, the schematics in PDF, and gerber files. Software using ChibiOS RTOS/HAL, and UAVCAN for communication. Bootloader based on libOpenCM3 and a custom lightweight protocol.","title":"Links"},{"location":"can/bootloader/","text":"CAN bootloader The bootloader is a general purpose bootloader, that we use on all our CAN boards. It allows us to flash them with application firmwares over CAN, thus removing the need to intervene directly on the boards (via debugger). And it stores a small config in the microcontroller's flash that makes it easily trackable (ID, board type). Its main features are: Firmware flashing over CAN, without intervention on the board directly. Firmware flashing is fast, a typical firmware (few hundred kilobytes) is written in a few seconds over a 1Mbps CAN interface. Parallel firmware flashing (using multicast) when several boards are flashed with the same firmware. Board tracking through small config containing ID, name, board type, and number of times the flash was erased. On power up, it waits for a few seconds for the user to input commands before jumping to the application. Application code is checked by CRC at boot, invalid applications are not loaded. Currently supported platforms are: All our boards at CVRA: motor, IO, sensor, and beacon boards. ST Nucleo STM32F103RB board ST Nucleo STM32F334R8 board Olimex E407 board (with STM32F407 onboard) Links Bootloader source code Supported platforms","title":"CAN bootloader"},{"location":"can/bootloader/#can-bootloader","text":"The bootloader is a general purpose bootloader, that we use on all our CAN boards. It allows us to flash them with application firmwares over CAN, thus removing the need to intervene directly on the boards (via debugger). And it stores a small config in the microcontroller's flash that makes it easily trackable (ID, board type). Its main features are: Firmware flashing over CAN, without intervention on the board directly. Firmware flashing is fast, a typical firmware (few hundred kilobytes) is written in a few seconds over a 1Mbps CAN interface. Parallel firmware flashing (using multicast) when several boards are flashed with the same firmware. Board tracking through small config containing ID, name, board type, and number of times the flash was erased. On power up, it waits for a few seconds for the user to input commands before jumping to the application. Application code is checked by CRC at boot, invalid applications are not loaded. Currently supported platforms are: All our boards at CVRA: motor, IO, sensor, and beacon boards. ST Nucleo STM32F103RB board ST Nucleo STM32F334R8 board Olimex E407 board (with STM32F407 onboard)","title":"CAN bootloader"},{"location":"can/bootloader/#links","text":"Bootloader source code Supported platforms","title":"Links"},{"location":"can/intro/","text":"CVRA's Robotics CAN Ecosystem An open-source panoply of UAVCAN connected boards to enable smart sensors and actuators for modular robotics development Motor board IO board Sensor board Beacon board CAN adapter CAN bootloader .container { position: relative; width: 50%; white-space: nowrap; display: table-cell; padding-right: 5px; } .image { display: inline; width: 100%; } .overlay { position: absolute; top: 0; bottom: 5px; left: 0; right: 5px; opacity: 0; transition: .5s ease; background-color: #264d73; } .container:hover .overlay { opacity: 0.8; } .text { color: white; font-size: 24px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); text-align: center; }","title":"CAN Ecosystem"},{"location":"can/io/","text":"IO board The IO board is a 23x15mm board with a dedicated STM32F3 microcontroller and the following features: CAN interface with communication over UAVCAN for IO control (read / write). CAN bootloader for easy firmware update over the bus. 11 GPIOs exposing: Digital outputs, including timer channels for PWM, Digital inputs, including timer channels for pulse counting, Analog inputs (ADC). Communication busses such as I\u00b2C and SPI. Molex Picoblade connection for wiring CAN in daisy chain. SWD connector for flashing and debugging, with UART exposed on the same connector. Costs < 10 USD in components. Current application software allows a general purpose usage exposing basic IO control over UAVCAN: PWM output and digital inputs. Links Hardware including KiCad files, the schematics in PDF, and gerber files. Software using ChibiOS RTOS/HAL, and UAVCAN for communication. Bootloader based on libOpenCM3 and a custom lightweight protocol.","title":"IO board"},{"location":"can/io/#io-board","text":"The IO board is a 23x15mm board with a dedicated STM32F3 microcontroller and the following features: CAN interface with communication over UAVCAN for IO control (read / write). CAN bootloader for easy firmware update over the bus. 11 GPIOs exposing: Digital outputs, including timer channels for PWM, Digital inputs, including timer channels for pulse counting, Analog inputs (ADC). Communication busses such as I\u00b2C and SPI. Molex Picoblade connection for wiring CAN in daisy chain. SWD connector for flashing and debugging, with UART exposed on the same connector. Costs < 10 USD in components. Current application software allows a general purpose usage exposing basic IO control over UAVCAN: PWM output and digital inputs.","title":"IO board"},{"location":"can/io/#links","text":"Hardware including KiCad files, the schematics in PDF, and gerber files. Software using ChibiOS RTOS/HAL, and UAVCAN for communication. Bootloader based on libOpenCM3 and a custom lightweight protocol.","title":"Links"},{"location":"can/motor/","text":"Motor board The Motor board is a small board (31x16mm) with a dedicated STM32F3 microcontroller that is at the core of all our robots since 2015. We have been using it to control DC motors, motor pumps, and RC servos. Here are its main features: CAN interface with communication over UAVCAN for parameter/gain setting, setpoint sending, and feedback streaming. CAN bootloader for easy firmware update over the bus. Control a single DC motor with current sensing, allowing cascaded PID control (torque, velocity, and position). H-bridge to drive the motor bidirectionally that supports driving a motor with up to 16.8V @ 6.6A continuously. Quadrature encoder interface for motor (5V tolerant). Secondary quadrature encoder interface (5V tolerant) (eg. for separate odometry wheels). Analog input for RC-servo control. Digital input for indexing, allows us to determine a reference location on a given axis that can be used for absolute positioning. Runs on 3 or 4 cell LiPo/LiFe batteries. SWD connector for flashing and debugging, with UART exposed on the same connector. Costs < 35 USD in components. Links Hardware including KiCad files, the schematics in PDF, and gerber files. Software using ChibiOS RTOS/HAL, and UAVCAN for communication. Bootloader based on libOpenCM3 and a custom lightweight protocol.","title":"Motor board"},{"location":"can/motor/#motor-board","text":"The Motor board is a small board (31x16mm) with a dedicated STM32F3 microcontroller that is at the core of all our robots since 2015. We have been using it to control DC motors, motor pumps, and RC servos. Here are its main features: CAN interface with communication over UAVCAN for parameter/gain setting, setpoint sending, and feedback streaming. CAN bootloader for easy firmware update over the bus. Control a single DC motor with current sensing, allowing cascaded PID control (torque, velocity, and position). H-bridge to drive the motor bidirectionally that supports driving a motor with up to 16.8V @ 6.6A continuously. Quadrature encoder interface for motor (5V tolerant). Secondary quadrature encoder interface (5V tolerant) (eg. for separate odometry wheels). Analog input for RC-servo control. Digital input for indexing, allows us to determine a reference location on a given axis that can be used for absolute positioning. Runs on 3 or 4 cell LiPo/LiFe batteries. SWD connector for flashing and debugging, with UART exposed on the same connector. Costs < 35 USD in components.","title":"Motor board"},{"location":"can/motor/#links","text":"Hardware including KiCad files, the schematics in PDF, and gerber files. Software using ChibiOS RTOS/HAL, and UAVCAN for communication. Bootloader based on libOpenCM3 and a custom lightweight protocol.","title":"Links"},{"location":"can/positioning/","text":"Positioning system Using our beacon board , we can build a positionning system. To do so, we will need a few fixed anchors whose positions are known. Then, we can use a moving tag that measures its distance to the anchors. Finally, a Kalman filter fuses those measurements into an absolute position. This principle is similar to the operation of GPS receivers. We tested this system both indoor and outdoor, on small (3mx2m) and larger (20mx20m) maps. It provides the position within 5 cm accuracy, at up to 50 Hz when using a single tag. We noticed that having 4 fixed anchors conditions the positioning better when using a non-coplanar constellation. This system is not too expensive compared to similar solutions. To get a 3D position we need 4 anchors and one tag per robot. Each board is 50$, for a total cost of 250$. For more information see the technical report .","title":"Positioning system"},{"location":"can/positioning/#positioning-system","text":"Using our beacon board , we can build a positionning system. To do so, we will need a few fixed anchors whose positions are known. Then, we can use a moving tag that measures its distance to the anchors. Finally, a Kalman filter fuses those measurements into an absolute position. This principle is similar to the operation of GPS receivers. We tested this system both indoor and outdoor, on small (3mx2m) and larger (20mx20m) maps. It provides the position within 5 cm accuracy, at up to 50 Hz when using a single tag. We noticed that having 4 fixed anchors conditions the positioning better when using a non-coplanar constellation. This system is not too expensive compared to similar solutions. To get a 3D position we need 4 anchors and one tag per robot. Each board is 50$, for a total cost of 250$. For more information see the technical report .","title":"Positioning system"},{"location":"can/sensor/","text":"Sensor board The Sensor board is a 23x17mm with a dedicated STM32F3 microcontroller and the following features: CAN interface over which sensor data are streamed over UAVCAN. CAN bootloader for easy firmware update over the bus. Distance time-of-flight sensor (VL6180X) can measure distances from 10mm to 100mm with 1mm resolution. RGB Color sensor (TCS34725) with external illumination using a white LED Molex Picoblade connection for wiring CAN in daisy chain. SWD connector for flashing and debugging, with UART exposed on the same connector. 2x M2 holes for mounting Costs < 25 USD in components. Current application software only supports the distance sensor. Color sensor support is work in progress. Links Hardware including KiCad files, the schematics in PDF, and gerber files. Software using ChibiOS RTOS/HAL, and UAVCAN for communication. Bootloader based on libOpenCM3 and a custom lightweight protocol.","title":"Sensor board"},{"location":"can/sensor/#sensor-board","text":"The Sensor board is a 23x17mm with a dedicated STM32F3 microcontroller and the following features: CAN interface over which sensor data are streamed over UAVCAN. CAN bootloader for easy firmware update over the bus. Distance time-of-flight sensor (VL6180X) can measure distances from 10mm to 100mm with 1mm resolution. RGB Color sensor (TCS34725) with external illumination using a white LED Molex Picoblade connection for wiring CAN in daisy chain. SWD connector for flashing and debugging, with UART exposed on the same connector. 2x M2 holes for mounting Costs < 25 USD in components. Current application software only supports the distance sensor. Color sensor support is work in progress.","title":"Sensor board"},{"location":"can/sensor/#links","text":"Hardware including KiCad files, the schematics in PDF, and gerber files. Software using ChibiOS RTOS/HAL, and UAVCAN for communication. Bootloader based on libOpenCM3 and a custom lightweight protocol.","title":"Links"}]}